トランザクションと同時実行制御
===

## <font color=magenta>トランザクション</font>
テーブルに対して行うCRUDではまとめて行われる場合があります。例えば該当するユーザを一括で削除するような場合などです。トランザクションはこのようなまとめて行う処理を指します。

MySQLでは、トランザクションを行うことのできないシンプルな仕組みの「MyISAM型」と一般的なDBMSと同じようにトランザクションを行える「InnoDB型」の2種類のテーブルを扱うことができます。

トランザクションは次の4つの特性によって定義され、頭文字をとって「ACID特性」と呼ばれています。

- Atomicity(原子性)
- Consistency(一貫性)
- Isolation(分離性または解離性、独立性)
- Durability(持続性)

### <font color=orange>Atomicity(原子性)</font>
データの更新(INSERT/UPDATE/DELETE)を伴う一連の動作が「すべて成功」または「すべて失敗」を保証する仕組みです。

例として「ユーザAがユーザBに5000円送金する」場合を考えます。システムは

1. ユーザAの口座から5000円引く
2. ユーザAからユーザBに5000円送られる
3. 5000円がユーザBの口座に加算される

トランザクション処理の場合、1〜3がすべて成功して初めてデータベースに半餌入れます。しかし途中で一部失敗してします場合を考えてみます。２では通信が発生しますが、ここで通信エラーとなってしまった場合、Aの口座は5000円分減少されただけでBの口座には加算されません。このようなことは起きてほしくないため、トランザクションではROLLBACKが行われます。

### <font color=orange>Consistency(一貫性)</font>
例えばユーザを登録する場合に、ユーザを一意にするためにユーザIDなどを連番で付与し、重複を防ぐような仕組みです。

### <font color=orange>Isolation(分離性または解離性、独立性)</font>
一連のデータ処理が複数のユーザから行われる場合に「それぞれの処理が矛盾なく行われること」を保証する仕組みです。

「ユーザAが5000円送金するタイミングで口座に5000円の引き落とし処理が行われる」場合を考えます。

1. 現在の空き部屋数を確認する(SELECT)
2. 確認した残数から1引き、結果を残数に書き戻す(UPDATE)

これをユーザAとユーザBが同時に行った場合、本来残部屋数は8になるはずですが1つしか減っていないことになります。

このようなことを防ぐために、データベースには更新されるデータ領域に対して**ロック**をかけて、皇族の処理をブロックする仕組みがあります。MySQLでトランザクション処理を行う場合は、基本的に行単位のロック機能を利用します。

### <font color=orange>Durability(持続性)</font>
一連のデータ操作(トランザクション操作)を完了(COMMIT)し、完了通知をユーザが受けた時点で、その操作が永続的隣結果が損なわれないことを示します。

これはシステムの正常時だけにとどまらず、DBサーバやOSの異常終了、つまりシステム障害に耐えるということです。

## <font color=magenta>トランザクション分離レベルによる見え方の違い</font>
### <font color=orange>MVCCによるMySQLの特性</font>
MySQL(InnoDB型テーブル)は、DBMSの主流となっている**MVCC(Multi Versioning Concurrency Control)** という技術を用いています。MVCCの利用によりMySQLは以下のような特性を持ちます。

1. 「読込」と「更新」は互いにブロックしない
2. 「読込」内容は分離レベルにより内容が変わる場合がある
3. 「更新」の際はロックを取得する。ロックは基本的に行単位で取得し、トランザクションが終了するまで保持する。分離レベルやInnoDBの設定により、実際にロックする行の範囲が異なる場合がある
4. 「更新」と「更新」は、後から来たトランザクションがロックを取得しようとしてブロックされる。一定時間待ち、その間にロックが取得できない場合には、ロックタイムアウトとなる
5. 「更新」した場合、更新前のデータをUNDOログとして「ロールバックセグメント」という領域に持つ。のUNDOログとしてログは用途が2つあり、一つは更新したトランザクションのロールバック時に更新前に戻す、もう一つは複数のトランザクションから分離レベルに応じて、対応する更新データを参照するために利用される(同じ行を更新するたびにUNDOログが作成され、同じ行に対して複数のバージョンが存在する事により1と2を実現している)

## <font color=magenta>ロックタイムアウトとデッドロックが起こる理由</font>
### <font color=orange>ロックタイムアウトとは</font>
「更新」と「更新」がぶつかった場合には後から来た更新がロック待ち状態になります。ロック元がいつロックを解放するのかを知る手段は、ロック解放を待っている側にはわかりませんので、一般的なDBMSではロックを待つ・待たない以外にどのくらいロックを待つか設定できます。

MySQLの場合は`innodb_lock_wait_timeout」というシステム変数で設定できます。ただし**waitしないという設定はできず最低1秒以上はwaitします**。

### <font color=orange>デッドロックとは</font>
例えば、ユーザAがテーブルaのロックを取得しユーザBがテーブルbのロックを取得したとします。そのロックを保持したままお互いにロック済みのリソースにロックが必要な処理(INSERT/UPDATE/DELETE)を行ったとき、いくら待っても状況が変わらない状態になります。これを**デッドロック**といいます。

## <font color=magenta>やってはいけないトランザクション処理</font>
### <font color=orange>大量の処理を一つのトランザクションで行う</font>
大量の更新処理を一つのトランザクションで行うと、トランザクションとしてその対象の更新処理をロールバックするために大量のUNDOログをトランザクション終了まで保持する必要があります。

UNDOログは不要になったタイミングで領域は開放され再利用されますが、OSのファイルシステムとしてのサイズは削減されません。そのため見かけ上無駄に大きなサイズになる場合があります。「1万件ごとにコミットを入れる」など分割すべきです。

### <font color=orange>トランザクション中に対話処理を入れる</font>
いつ終わるかわからない対話処理のようなものをトランザクション中に入れるべきではありません。

### <font color=orange>処理能力以上のトランザクション数</font>
トランザクションでは何らかのロックを伴って処理を行っています。そのため、このロックが他のトランザクションを妨げる場合があります。処理能力以上のトランザクション数だとロックタイムアウトやデッドロックの確率が上がります。

MySQLではDBサーバとのコネクション数上限を設定する`max_connections」というシステム変数があります。
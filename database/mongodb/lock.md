ロックについて
===

- [Lock](https://docs.mongodb.com/manual/faq/concurrency/#what-type-of-locking-does-mongodb-use-)

マルチグラニュラリティロックを採用。グローバル/データベース/コレクションレベルでロックを操作できる。ストレージエンジンによってコレクションレベル以下で独自の並行制御を実装することも可能。WiredTigerではドキュメントレベルでロック。

MongoDBはreader-writerロックを使っている。これはデータベースやドキュメントなどのリソースに対して同時に読む人が共有アクセスできるようにするもの。

読み込み時の共有ロック(S)、書き込み時の排他ロック(X)に加えて、インテント共有(IS)、インテント排他(IXモードは、より細かい粒度のロックを使用してリソースの読み込みまたは書き込みの意図を示す。ある粒度でロックすると、Sれより上の階層はすべてインテントロックされる。

[インテンションロックについて](https://dev.mysql.com/doc/refman/8.0/ja/innodb-locking.html#innodb-intention-locks)

例えば、コレクションを書き込みようにロックする場合(モードXを使用)、対応するデータベースロックとグローバルロックの療法をインテント排他ロックモードでロックする必要がある。一つのDBをISモードとIXモードで同時にロックすることができるが、排他ロック(X)モードは他のモードと共存できず、Sロックはインテント共有ロック(IS)としか共存できない。

ロックは公平に行われ、読み込みと書き込みのロック要求は順番にキューに入れられる。しかし、スループットを最適化するために、あるロック要求が許可されると、互換性のある他のすべてのロック要求も同時に許可され、競合するロック要求が実行される前にロックが解放される可能性がある。例えば、Xのロックが解放されたばかりで、競合キューにこれらのロックが含まれている状況を考えてみる。

IS => IS => X => X => S => IS

厳密な先入れ先出し(FIFO)順序では、最初の2つのISモードだけが許可される。そうではなく、MongoDBは実際にすべてのISモードとSモードを許可し、それらがすべてなくなると、新しいISやSのリクエストがキューに入っていたとしてもXを許可する。付与されると他のすべてのリクエストがキューに入るので、キューイング先が枯渇することはない。

WiredTigerでは、ほとんどの読み書き操作に楽観的な同時実行制御を採用している。WiredTigerでは、グローバルレベル、データベース、コレクションレベルでインテントロックのみを使用している。ストレージエンジンが2つの操作の競合を検知すると、片方の操作では書き込みの競合が発生し、MongoDBは透過的にその操作を再試行する。

### 一般的なロックの使われ方

[What locks are taken by some common client operations?](https://docs.mongodb.com/manual/faq/concurrency/#what-locks-are-taken-by-some-common-client-operations-)

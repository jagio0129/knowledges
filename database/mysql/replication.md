レプリケーション
===

## レプリケーションとは
- データの複製(レプリカ)を別サーバにバックアップする機能
- MySQLには標準で搭載されている

## マスター・スレーブ構成
- サーバはマスター・スレーブまたは両方になれる
- マスターサーバ
  - データの変更
  - 変更内容をスレーブに転送
  - マスタは複数のスレーブを持てる
- スレーブサーバ
  - マスタから受け取る変更内容をDBに反映
  - マスターを一つだけ持てる

## メリット
- 参照性能の向上
- 高可用性構成の実現
  - マスター障害児にスレーブをマスターに昇格できる
- 地理的冗長性の実現
  - 地理的に離れたところでもマスター・スレーブ構成が組める
- バックアップサーバとしての利用
  -スレーブにバックアップをもたせるので、マスターサーバに影響を与えずにバックアップできる

## 仕組み

マスターサーバでのすべての変更点をバイナリログに記録し、バイナリログの内容をスレーブに転送し、実行することで実現

1. スレーブがレプリケーションの開始をマスターにリクエスト
2. マスターがレプリケーションデータをスレーブに転送
3. リレーログの内容をスレーブに適用
4. log-slave-updatesを設定している場合、スレーブでもバイナリログを出力（多段構成のレプリケーション時必須）

### バイナリログ
- 発行されたクエリのうち、更新系のSQL分のみを記録しているログファイル
- バイナリ形式


## レプリケーションの種類

### ステートメントベースレプリケーション(SBR)
- 実行されるSQL文がバイナリログに記載されている

### 行ベースレプリケーション(RBR)
- SBRとは反対に、データそのものをバイナリログに記録

### 混合レプリケーション(MBR)
- SBRとRBRの混合
- MySQL5.1.12以降デフォ
- どういうときにSBRとRBRが切り替わるのか？
  - 実行のたびに結果が変わる場合はSQL文でなくデータそのもので同期を取る必要があるときにRBR
    - SBRでUUID()とかSYSDATE()を実行した場合、SBRではバイナリログにSQLが記録されて、そのままスレーブで実行するとマスターと異なる値が記録されてしまう。

## GTID
- コミット済みのトランザクション単位に与えられる一意識別子
- `erver_uuid : transaction_id`で表す

### GTIDを使用したレプリケーションの制限事項
以下3点はマスターサーバでエラーとなる

- `CREATE TABLE ... SELECT`
- トランザクション内のトランザクションおよび非トランザクションテーブルの両方を更新する
- トランザクション内の`CREATE TEMPORARY TABLE` ステートメント
  - トランザクション外での`CREATE TEMPORARY TABLE`はtmpテーブル作成される

### 参考
- [MySQL入門 レプリケーション編](https://qiita.com/Tocyuki/items/c224cef57493f536a941)
- [GTIDを使用したレプリケーション構成を作成する［1］](https://gihyo.jp/dev/serial/01/mysql-road-construction-news/0024)
- [行ベースレプリケーションの遅延について](https://gihyo.jp/dev/serial/01/mysql-road-construction-news/0034)
- [MySQLレプリケーションを安全に利用するための10のテクニック](http://nippondanji.blogspot.com/2009/03/mysql10.html)
- [MySQLレプリケーション再入門](https://qiita.com/snoguchi/items/43247a433973d09f7c08)
- [ステートメントベースおよび行ベースレプリケーションのメリットとデメリット](https://dev.mysql.com/doc/refman/5.6/ja/replication-sbr-rbr.html)

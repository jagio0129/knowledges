# Objective-C
- http://wisdom.sakura.ne.jp/programming/objc/index.html

## 概要
- SmalltalkベースのC言語拡張言語
  - javaやC++とは異なる
  - 正確にはCのコンパイラを拡張させたもの。なので**Cも動く**
- オブジェクト指向
- GCCコンパイラで動くのでLinux上でも動く
- `#import`でヘッダを読み込む。`#include`と違うのは、**一度includeされたファイルは再インクルードされないこと**

## コンパイラディレクティブ
- クラス宣言にはコンパイラディレクティブが必要
  - ＠マークで始まる
  - `＠interface`で始まり`＠end`でおわる
  ```
  @interface クラス名:親クラス名{
    インスタンス変数宣言
  }
  @end
  ```

- 親クラスを指定しないクラスをルートクラスという
  - ルートクラス宣言は以下
  ```
  @interface クラス名{
    インスタンス変数宣言
  }
  メソッド宣言
  @end
  ```

- 通常は処理系が提供するルートクラスを継承する
- ルートクラスはクラスが正常に動作するために必要な基本的機能を提供する役割があるから、継承が必要となる
- メソッド宣言
  ```
  - (戻り値) メソッド名:仮引数リスト ...;
  ```
  - 最初のマイナス記号は「このメソッドがクラスの実態であるオブジェクトに関すること」をあらわあしている。
  - 「-」はインスタンスメソッド
  - 「＋」はクラスメソッド
- クラスの宣言では、インスタンス変数とメソッドの宣言しかできない。
- クラスを宣言から定義へと具体化するには`@implementation`コンパイラディレクティブを用いてクラスを定義しなければならない

## クラスのインスタンス
- JavaやC++などはnew演算子が存在しインスタンスを生成できる
  - Objective-Cでは**インスタンスの生成も含めてクラスが行わなければならない**
- クラスのインスタンス化には、オブジェクトに必要なサイズを調べ、メモリを割り当てるなどが必要
  - この作業をするのがルートクラス(Objectクラス)
- Objectクラスには、自身を含めたそれを継承するクラスのインスタンスを適切に生成する`alloc`クラスメソッドを定義
  - `+ alloc;`
- クラスメソッドの呼び出し方
  - `[クラス名 メソッド名:引数リスト...]`
  - []でメソッドを呼び出すのをメッセージ式と呼ぶ

### 簡単な例
```objective-c
#import <stdio.h>
#import <objc/Object.h>

# クラス定義
@interface Test : Object
  - (void)method;
@end

# クラス実装
@implementation Test
  - (void)method {
    printf("Kitty on your lap\n");
  }
@end

int main() {
  id obj = [Test alloc];  # Testクラスのインスタンス生成
  [obj method];           # Testクラスのインスタンスメソッドmethodを呼び出し
	
  return 0;
}
```

1. @interfaceでルートクラスObjectを継承したTestクラスを宣言
2. 戻り値を返さず、引数をうけとらないmethodメソッドを宣言
3. @implementでTestクラスを実装
4. クラスの宣言と実装が完了したのでmain()で利用可

- 例のように、クラスの宣言と定義の場所は自由だが慣習として以下
  - クラス宣言はヘッダファイル。
  - 定義はクラス名と同じ名前の*.mファイル

## アクセッサメソッド
- 原則としてクラスのインスタンス変数には**クラスの外部からはアクセスすることができない**
- 複数の引数がある場合
  - `- (戻り値型) メソッド名:(引数型) 変数名 ラベル：`
  - ラベルが付いていることで、この時戻り値、引数、メソッド名を持つメソッドを区別できる